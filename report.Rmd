---
title: "Report"
output:
  html_document:
    code_folding: hide 
---

```{r, message=FALSE}
# Load packages 
library(tidyverse)
library(ggplot2)
library(modelr)
library(mgcv)
library(dplyr)
library(tidyr)
library(patchwork)
library(lme4)
library(lmerTest)
library(ggsci)

# Set plot theme
theme_set(theme_minimal() + theme(legend.position = "bottom"))
options(
  ggplot2.discrete.colour = function(...) scale_colour_brewer(..., palette = "Pastel2"),
  ggplot2.discrete.fill   = function(...) scale_fill_brewer(..., palette = "Pastel2"),

  ggplot2.continuous.colour = function(...) scale_colour_distiller(..., palette = "PuRd"),
  ggplot2.continuous.fill   = function(...) scale_fill_distiller(..., palette = "PuRd")
)
```

# Motivation
Half of the world's population has experineced or will experience menstruation; for many, this physiologic function occurs monthly for several decades. For young adults who menstruate, symptoms and regular menstration can be a vital health indicator. Abnormal symptoms can further suggest reproductive tract abnormalities, such as uterine fibroids or endometriosis. However, abnormal symptoms such as heavy bleeding or extreme pain can also be attributed to lifestyle characteristics. By leveraging a cohort of young adult menstruators, we hope to better understand the relationship between physiological menstrual characteristics and lifestyle factors such as stress, sleep, and exercise. Understanding how day-to-day factors influence menstrual health can help individuals who menstruate understand how to better manage concerning symptoms or identify when abnormal symptoms could be indicative of a more serious health concern. 

# Related Work

# Questions


# Data

We utilized the inclusive, multimodal, longitudinal, and de-identified [mcPHASES](https://physionet.org/content/mcphases/1.0.0/) (menstrual cycle Physiological, Hormonal, and Self-Reported Events and Symptoms) dataset for menstrual health tracking with wearable devices.

Data was collected from 42 menstruating young adults in Canada over two 3-month intervals (one in 2022, and the other in 2024). Participants wore Fitbit Sense smartwatches to measure physiological signals, and Mira Plus Starter Kits to track their hormone levels. Participants also self-reported daily symptom experiences like cramps, sleep quality, and stress levels via a smartphone diary app.

The original dataset contains 23 structured tables organized by signal category. For this project, we focused on the lifestyle factors such as exercise, sleep, and stress, and menstrual cycle symptoms. The datasets we used are the following:

-   Demographics:
    -   `subject_info.csv`: static information such as age, education, and age at menarche
    -   `height_and_weight.csv`: participant's baselien height and weight
-   Hormone and Symptoms:
    -   `hormones_and_selfreport.csv`：self-reported daily data including symptoms (e.g., cramps, mood, menstrual flow) and manually entered hormone levels (LH, E3G, PdG)
-   Lifestyle Factors:
    -   `stress_score.csv` [TODO]
    -   `sleep.csv`: sleep stages, time in bed
    -   `sleep_score.csv`

------------------------------------------------------------------------

In total, we have 4 dataframes:

1.  `subject_info` (demographics data)
2.  `hormone_symptoms` (hormone and symtoms data)
3.  `sleep_stress` (sleep and stress related data)
4.  `exercise` (exercise related data).

For different analyses, we merged the dataframes above by participant `id` as needed.

------------------------------------------------------------------------

### `subject_info`  - Subject-Relevant Data

The `subject_info` dataframe contains participants demographics data from `subject_info.csv` and `height_and_weight.csv`, as well as participants study enrollment year (this piece of information is from `hormones_and_selfreport.csv`).

It contains a total of 62 observations of 19 variables. Some key variables are the following:

-   `id`: participant's unique identifier
-   Age relevant variables: `birth_year` and `age_of_first_menarche`
-   Height and weight related variables: `avg_height`, `avg_weight`, `bmi`
-   Study enrollment related information: `study` (flag of which study the participant enrolled in, `1`=2022, `2`=2024, `3`=both), `year` (the year of study)
-   Categorical variables like `ethnicity`, `education`, `self_report_menstrual_health_literacy`, etc.

```{r ht-and-wt, message=FALSE}
ht_wt = read_csv("data/height_and_weight.csv")|> 
  janitor::clean_names() |> 
  # calculate mean height/weight
  rowwise() |>
  mutate(
    avg_height = mean(c(height_2022, height_2024), na.rm = TRUE),
    avg_weight = mean(c(weight_2022, weight_2024), na.rm = TRUE)
  ) |>
  ungroup()
```

```{r, message=FALSE}
# import csv file
hormones_and_selfreport = read_csv("data/hormones_and_selfreport.csv") |> 
  janitor::clean_names() 
# extract study_flag
study_flag <- hormones_and_selfreport  |> 
  distinct(id, study_interval) |> 
  mutate(flag = 1,
         study_interval = paste0("study_", study_interval)) |> 
  pivot_wider(
    names_from = study_interval,
    values_from = flag,
    values_fill = 0  
  )
```

```{r, message=FALSE}
# read in subject-info.csv
subject_info_raw = read_csv("data/subject-info.csv") |> 
  janitor::clean_names()

subject_info <- subject_info_raw  |> 
  # merging
  left_join(ht_wt, by = "id") |> 
  left_join(study_flag, by = "id") |>
  # add a study_flag
  mutate(
    study = case_when(
      study_2022 == 1 & study_2024 == 1 ~ 3L,  # both 2022 & 2024
      study_2022 == 1 & study_2024 == 0 ~ 1L,  
      study_2024 == 1 & study_2022 == 0 ~ 2L,  
      TRUE ~ NA_integer_
    )
  ) |> 
  # pivot_long for wt & ht
  pivot_longer(
    cols = c(weight_2022, weight_2024, height_2022, height_2024),
    names_to  = c(".value", "year"), 
    names_sep = "_"                 
  ) |> 
  rename(
    weight_yr = weight,
    height_yr = height
  ) |> 
  # keep only the relevant study year
  filter(
    (study == 1 & year == 2022) |
    (study == 2 & year == 2024) |
    (study == 3)
  ) |> 
  # calculate age
  mutate(
    year = as.numeric(year),
    birth_year = as.numeric(birth_year),
    age = year - birth_year
  ) |> 
  # get a mean age for each id
  group_by(id) |> 
  mutate(
    mean_age = mean(age, na.rm = TRUE)
  ) |> 
  ungroup() |> 
  # get BMI
  mutate(
    bmi = weight_yr / ( (height_yr / 100)^2 )
  )|>
  # convert NaN to NA
  mutate(
    across(c(avg_weight, avg_height), 
           ~ if_else(is.nan(.), NA_real_, .))
  ) |> 
  #this factors variables and also creates "gender abrv" and "education abrv", which are simplified versions of these variables for cleaner tables and figures 
  mutate(
    education = str_trim(education),
    education_abrv = case_when(
      education == "High school degree or equivalent (e.g. GED)" ~ "High School",
      education == "Some university/ post-secondary, no degree" ~ "Some College",
      education == "Bachelor's degree (e.g. BA, BS)" ~ "Bachelors",
      education %in% c("Master's degree (e.g. MA, MS, MEd)", "Doctorate or professional degree") ~ "Graduate Degree or Higher",
      TRUE ~ "Other"),
    education_abrv = factor(
      education_abrv,
      levels = c("High School", "Some College", "Bachelors", "Graduate Degree or Higher", "Other"),
      ordered = TRUE),
     self_report_menstrual_health_literacy = factor(
      self_report_menstrual_health_literacy,
      levels = c("Non-existant", "Low", "Medium", "High"),
      ordered = TRUE),
    gender_abrv = case_when(
      gender %in% c("Gender Fluid", "Non-binary") ~ "Gender Fluid or Non-binary", 
      gender %in% c("Prefer not to say", "Other") ~ "Prefer not to say or Other", 
      gender == "Woman" ~ "Woman"),
      gender_abrv = factor(gender_abrv, levels = c("Woman", "Gender Fluid or Non-binary", "Prefer not to say or Other")), 
      sexually_active = factor(sexually_active, levels = c("Yes", "No", "Prefer not to say"))) |> 
  # only need 1 study_interval flag to indicate the study year
  mutate(study_interval = year) |> 
  select(-study_2022, -study_2024, -year, -study) |> 
  # rearrange the column order
  select(
    id,     
    study_interval,     
    everything()
  )
  
```

### `hormone_symptoms` - Hormone & Self-reported Data

[TODO] add overview

```{r, message=FALSE}
# read in raw csv file
hormone_symptoms_raw <- 
  read_csv("data/hormones_and_selfreport.csv") |> 
  janitor::clean_names() 

# factor string values
likert_level_factor = c("not at all", "very low/little", "low", "moderate", "high", "very high")
likert_levels_no_verylowlittle = c("not at all", "very low", "low", "moderate", "high", "very high")
# likert_scale for numeric score conversion
likert_6_levels = c("not at all" = 0, "very low/little" = 1, "very low" = 1, "low" = 2, "moderate" = 3, "high" = 4, "very high" = 5)


hormone_symptoms <- hormone_symptoms_raw |> 
  # convert all to lower case string for standardization
  mutate(across(flow_volume:bloating, 
                ~ ifelse(!is.na(.) & !grepl("^\\d+$", .), tolower(.), .))) |> 
  mutate(across(c(phase), ~ ifelse(!is.na(.) & !grepl("^\\d+$", .), tolower(.), .))) |> 
  # factor variables
  mutate(
    phase = factor(phase, levels = c("menstrual", "follicular", "fertility", "luteal")),
    flow_volume = factor(flow_volume, 
                         levels = c("not at all", "spotting / very light","light","moderate", "somewhat heavy","heavy", "very heavy")),
    flow_color = factor(flow_color,
                        levels = c("not at all", "pink","bright red", "dark brown / dark red", "grey", "black","other")),
  ) |> 
  # factor character values
  mutate(
    across(
    .cols = c(sleepissue, headaches, stress, cramps, foodcravings, indigestion, bloating, moodswing, sorebreasts, fatigue),  
    .fns = ~ factor(., levels = likert_level_factor),  
    .names = "{.col}"  
  )
  ) |> 
  mutate(across(
    .cols = c(appetite, exerciselevel),
    .fns = ~ factor(., levels = likert_levels_no_verylowlittle), 
    .names = "{.col}"  
  )) |> 
  # convert categorical variable values to numeric intensity scores
  mutate(across(
    .cols = appetite:bloating,
    .fns = ~ recode(., !!!likert_6_levels),
    .names = "{.col}_score"
  )) |> 
  # special conversion for flow
  mutate(
    flow_volume_score = case_when(
      flow_volume == "not at all" ~ 0,
      flow_volume == "spotting / very light" ~ 1,
      flow_volume == "light" ~ 2,
      flow_volume == "moderate" ~ 3,
      flow_volume == "somewhat heavy" ~ 4,
      flow_volume == "heavy" ~ 5,
      flow_volume == "very heavy" ~ 6,
      TRUE ~ NA_real_
    ),
    flow_color_score = case_when(
      flow_color == "not at all" ~ 0,
      flow_color == "pink" ~ 1,
      flow_color == "bright red" ~ 2,
      flow_color == "dark brown / dark red" ~ 3,
      flow_color == "grey" ~ 4,
      flow_color == "black" ~ 5,
      flow_color == "other" ~ 6,
      TRUE ~ NA_real_
    )
  )


#hormone_symptoms |> 
#  filter(is.na(phase))
```

### `exercise`

```{r, include = FALSE}
# Read data
exercise_raw <- read_csv("data/exercise.csv") |> 
  janitor::clean_names() 

exercise_daily <- exercise_raw |> 
  distinct() |> 
#  select(id, study_interval, start_day_in_study, activityname, duration, activeduration, averageheartrate) |> 
  # Aggregate to daily level
  group_by(id, study_interval, start_day_in_study) %>%
  summarise(
    total_calories = sum(calories, na.rm = TRUE),
    total_duration_min = sum(duration, na.rm = TRUE) / 60000,
    total_active_min = sum(activeduration, na.rm = TRUE) / 60000,
    total_steps = sum(steps, na.rm = TRUE),
    avg_heartrate = mean(averageheartrate, na.rm = TRUE),
    max_heartrate = ifelse(all(is.na(averageheartrate)), NA, max(averageheartrate, na.rm = TRUE)),  # Handling -Inf
    total_elevation = sum(elevationgain, na.rm = TRUE),
    n_sessions = n(),
    activity_types = paste(unique(activityname), collapse = ", "),
    .groups = "drop"
  ) |> 
  rename(day_in_study = start_day_in_study) 
```


### `sleep_stress`
[TODO] add overview

```{r, message=FALSE}
# load raw data from csv files
sleep_score_raw <- read_csv("data/sleep_score.csv") |>
  janitor::clean_names()
sleep_raw       <- read_csv("data/sleep.csv") |>
  janitor::clean_names()
stress_score_raw <- read_csv("data/stress_score.csv") |>
  janitor::clean_names()

# combine the sleep and stress score
sleep_score <- sleep_score_raw |>
  select(id,study_interval, day_in_study, overall_score, deep_sleep_in_minutes) |> 
  mutate(sleep_score = overall_score) |> 
  select(-overall_score) |> 
  # remove duplicates by keeping the maximum score
  group_by(id, study_interval, day_in_study) |> 
  slice_max(order_by = sleep_score, n = 1, with_ties = FALSE) |> 
  ungroup()

stress_score <- stress_score_raw |>
  filter(calculation_failed == "FALSE")|>
  select(id, study_interval, day_in_study, stress_score)|>
  distinct(id, study_interval, day_in_study, .keep_all = TRUE)


sleep_stress_score <- full_join(sleep_score, stress_score, by=c("id", "study_interval", "day_in_study"))

# check duplicates >> no duplicates nice
#sleep_stress_score %>%
#  group_by(id, study_interval, day_in_study) %>%
#  filter(n() > 1)

# check of na values
#sum(is.na(sleep_stress$overall_score))
#sum(is.na(sleep_stress$stress_score))

# check how many days have both scores
#sleep_stress_score %>%
#  filter(!is.na(stress_score) & !is.na(sleep_score)) |> 
#  nrow()
```


```{r, message=FALSE}
# working on sleep data
sleep <- sleep_raw|>
  select(id,study_interval, sleep_end_day_in_study, timeinbed, mainsleep) |>
  # changed to sleep_end_day
  mutate(day_in_study = sleep_end_day_in_study) |>
  select(-sleep_end_day_in_study) |> 
  # only keep main sleep = TRUE as mainsleep: boolean indicating whether this is the main sleep session of the day
  filter(
    mainsleep == TRUE
  ) |> 
# check duplicates >> all duplicates from 2024
  group_by(id, study_interval, day_in_study) |>
  summarise(
    timeinbed_mean = mean(timeinbed, na.rm = TRUE),
    mainsleep = first(mainsleep),
    .groups = "drop" 
  ) |>
  ungroup() |> 
  # no need flag
  select(-mainsleep)

# check duplicates
#sleep |> 
 # filter(study_interval == 2022) |> 
#  pull(timeinbed) |> 
#  mean(na.rm = TRUE)
  
#sleep |> count(id, study_interval, day_in_study) |>
 # filter(n > 1)

sleep_stress_daily <- full_join(sleep, sleep_stress_score, by=c("id", "study_interval", "day_in_study"))


#sleep %>%
 # group_by(id, study_interval, day_in_study) %>%
  #summarise(
   # total_timeinbed = sum(timeinbed, na.rm = TRUE),
    #.groups = "drop"  # 去除分组，返回一个没有分组的 data frame
#  ) |> 
 # filter(total_timeinbed>2000)
  
 # ggplot(aes(x = total_timeinbed)) +
#  geom_density(fill = "skyblue", alpha = 0.5) +  # 填充颜色为淡蓝色，透明度为0.5
#  labs(title = "Density Distribution of Total Time in Bed", 
 #      x = "Total Time in Bed (hours)", 
  #     y = "Density")
```


### `all_daily_data` - Merged dataset

We used `hormone_symptoms` as our anchor dataframe since all of our outcome variables are from `hormone_symptoms`; hence, we used `left_join` on it. In other words, if a person did not have any hormone/symptoms related data on a given day, she would not have any other types of data on that day (e.g. no exercise/stress/sleep) in the merged dataset called `all_daily_data`.

So now in this `all_daily_data`, each row represents a daily data for a person in a specific study year (including sleep score, stress score, daily exercise data, hormone and self-reported symptoms).

First merged daily exercise data, then merged daily stress and sleep data. 

```{r, message=FALSE}

all_daily_data <- hormone_symptoms |> 
  # MERGE exercise & hormone
  left_join(exercise_daily, by = c("id", "study_interval", "day_in_study")) |>
  # add flag exercised_flag for easy filtering in the future analyses
  # only need to keep exercised_flag==1 to have all rows with exercise data
  mutate(
    exercised_flag = ifelse(!is.na(n_sessions) & n_sessions > 0, 1, 0)
    # Replace NA with 0 for days without exercise ## NA might be not wearing the device instead of not exercising, I think it's better to remove them. Converting to 0 might cause very biased (right skewed) data/results
    #total_duration_min = replace_na(total_duration_min, 0),
    #total_active_min = replace_na(total_active_min, 0),
  ) |> 
  # Remove individuals with no phase
  # filter(!is.na(phase))

  # MERGE sleep & stress score data
  # noticed hormone_symptoms df has a stress_score column 
  # drop it
  select(-stress_score) |> 
  left_join(sleep_stress_daily, by = c("id", "study_interval", "day_in_study")) |> 
  # add flag sleep_stress_flag for easy filtering in the future analyses
  mutate(
    sleep_stress_flag = ifelse(
      !is.na(stress_score) & !is.na(sleep_score),1,0
    )
  )  
  # MERGE demographic data
  # left_join(subject_info, by = c("id", "study_interval")) 
  
```


# EDA
-hormone

```{r, include=FALSE}
hormone_symptoms=
  read_csv("clean_data/hormone_symptoms.csv")|>
  janitor::clean_names()|>
  filter(!is.na(phase) & !is.na(moodswing) & !is.na(fatigue)& !is.na(flow_color)& !is.na(flow_volume)& !is.na(appetite))
```

###LH & Estrogen Across Phases
Topic: Examine average estrogen and LH levels across menstrual cycle phases to see if hormonal patterns match biological expectations
```{r, echo=FALSE}
hormone_avg <- hormone_symptoms |>
  group_by(phase) |>
  summarise(
    estrogen_mean = mean(estrogen, na.rm = TRUE),
    lh_mean = mean(lh, na.rm = TRUE),
    .groups = "drop"
  )

ggplot(hormone_avg, aes(x = phase)) +
  geom_line(aes(y = estrogen_mean, color = "Estrogen", group = 1), size = 1) +
  geom_line(aes(y = lh_mean, color = "LH", group = 1), size = 1) +
  geom_point(aes(y = estrogen_mean, color = "Estrogen"), size = 3) +
  geom_point(aes(y = lh_mean, color = "LH"), size = 3) +
  labs(title = "Average Estrogen and LH Across Cycle",
       x = "Phase", y = "Hormone Level", color = "Hormone") +
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
    plot.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey90")
  )
```
Estrogen levels are highest in the Fertility (ovulatory) phase, second highest in Luteal, and relatively low in Menstrual, gradually rising from Follicular to Luteal. LH is much lower than estrogen overall, peaking sharply in Fertility and remaining low in the other phases.


###Mood Swing Distribution Across Phases
Topic: Assess whether menstrual cycle phases influence mood swing intensity using violin plots.
```{r, echo=FALSE}
# Mood swing
ggplot(hormone_symptoms, aes(x = phase, y = moodswing_score)) +
  geom_violin(trim = TRUE, fill = "orchid", alpha = 0.5) +
  geom_jitter(width = 0.15, alpha = 0.3, size = 1) +
  scale_y_continuous(limits = c(0,5), breaks = 0:5) +
  labs(
    title = "Distribution of Mood Swing Intensity Across Phases",
    x = "Phase",
    y = "Mood Swing (0–5)"
  ) + 
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
    plot.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey90")
  )

```
Violin plots show substantial inter-individual variability. Menstrual phase has the highest mood swing intensity (right-skewed distribution, peak around 1.85), while Luteal phase shows lower values with a wider base (more individuals with low mood swing).


###Average Mood Swing Across Phases

Topic: Summarize average mood swing intensity across phases to visualize general trends.
```{r, echo=FALSE}
symptom_means <- hormone_symptoms |>
  group_by(phase) |>
  summarise(
    avg_moodswing = mean(moodswing_score, na.rm = TRUE),
    .groups = "drop"
  )

# Mood swing single line plot
ggplot(symptom_means, aes(x = phase, y = avg_moodswing, group = 1)) +
  geom_line(color = "purple", size = 1.5, alpha = 0.7) +
  geom_point(color = "purple", size = 3) +
  geom_text(aes(label = round(avg_moodswing, 2)), vjust = -1, size = 4, fontface = "bold") +
  labs(
    title = "Average Mood Swing Intensity Across Menstrual Cycle Phases",
    subtitle = "Higher values indicate more severe mood swings (Scale: 1-4)",
    x = "Phase",
    y = "Average Mood Swing Intensity"
  ) +
  ylim(0, 4) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
    plot.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey90")
  )

```

Average mood swing is highest in Menstrual phase (1.85), lowest in Luteal phase (1.41), with intermediate levels in follicular and fertility phases.






###Mood Swing & Fatigue Linear Mixed Models

Topic: Test whether mood swing and fatigue differ by menstrual phase, accounting for repeated measures.
```{r, echo=FALSE}
mood_mixed_model <- lmer(moodswing_score ~ phase + (1 | id), data = hormone_symptoms)
fatigue_mixed_model <- lmer(fatigue_score ~ phase + (1 | id), data = hormone_symptoms)


mood_mixed_model
fatigue_mixed_model
```

Mood swings are lowest near ovulation, slightly higher in Luteal, and peak during Menstrual phase. Fatigue shows a similar pattern: lowest near ovulation, increasing through Luteal, highest during Menstrual phase. Random effects indicate that some individuals are chronically more fatigued or mood-sensitive than others, while residual variance captures day-to-day variability.


###Flow Volume Distribution Across Phases

Topic: Visualize flow volume variation across phases with violin plots to assess distribution patterns. 
```{r, echo=FALSE}
#violin
ggplot(hormone_symptoms, aes(x = phase, y = flow_volume_score)) +
  geom_violin(fill = "skyblue", alpha = 0.5) +  
  labs(
    title = "Distribution of Flow Volume Across Phases",
    x = "Phase", y = "Flow Volume (0–6)"
  ) +
  theme_minimal()
```
Luteal phase shows a right-skewed distribution, indicating most low-flow observations but a few high-flow days. Menstrual phase is narrow and tall, indicating consistently higher flow intensity.

Average Flow Volume and Appetite Across Phases

Topic: Summarize average flow volume and appetite to observe general trends across the menstrual cycle.
```{r, echo=FALSE}
cycle_avg <- hormone_symptoms |>
  group_by(phase) |>
  summarise(
    avg_flow_volume = mean(flow_volume_score, na.rm = TRUE),
    avg_appetite    = mean(appetite_score, na.rm = TRUE),
    .groups = "drop"
  )

# Flow Volume
ggplot(cycle_avg, aes(x = phase, y = avg_flow_volume, group = 1)) +
  geom_line(size = 1.2, color = "blue") +
  geom_point(size = 3, color = "red") +
  geom_text(aes(label = round(avg_flow_volume, 2)), vjust = -1, size = 4, fontface = "bold") +
  labs(title = "Average Flow Volume Across Phases",
       x = "Phase", y = "Flow Volume Score") +
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
    plot.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey90")
  )

```
Menstrual phase has the highest average flow (2.38), Luteal is lowest (0.03), Fertility is 0.07, and Follicular is 0.23.


```{r, echo=FALSE}
# Appetite
ggplot(cycle_avg, aes(x = phase, y = avg_appetite, group = 1)) +
  geom_line(size = 1.2, color = "purple") +
  geom_point(size = 3, color = "red") +
  geom_text(aes(label = round(avg_appetite, 2)), vjust = -1, size = 4, fontface = "bold") +
  labs(title = "Average Appetite Across Phases",
       x = "Phase", y = "Appetite Score") +
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
    plot.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey90")
  )
```
Appetite is highest in Fertility (2.96), lowest in Follicular (2.85), Luteal 2.95, Menstrual 2.90.


###Linear Mixed Model: Appetite vs Estrogen
Topic: Explore the relationship between estrogen levels and appetite scores, accounting for repeated measures.
```{r, echo=FALSE}
appetite_model <- lmer(appetite_score ~ estrogen + (1 | id), data = hormone_symptoms)
summary(appetite_model)
```
Random intercept variance (0.1746) indicates participant-specific baseline appetite differences. The fixed effect of estrogen is small (0.00013 per unit) and not significant (t = 0.869).


# Modelling

# Discussion

### Data Handling
- data quality issues - take hormones & self-reported as an example

regardless the most common missing data (due to self-report), 1) integer values in categorical variables; 2) inconsistent likert scale ('very low/little' vs. 'very low') >> give us the tip when we run a study to collect different likert scale data, collect them at the same scale for easy and consistent future data analyses.

- data entry issues - take sleep.csv as an example

## Limitation


